This research aims to reduce GC-related spikes that cause
performance interference in multitenant scenarios. The prior development
phases have focused on the performance of \emph{A Cat on a Bed} for an
individual JVM. This section instead focuses on the multitenant
scenario, research question 2, and how \emph{A Cat on a Bed} functions with
other JVMs. Addressing this research question requires forming a game
theory model and testing in multitenant scenarios with Kubernetes. The
approach is separated into two areas: theoretical, relating to game
theory, and practical, applying Kubernetes.
\subsection{Theoretical approach (Game theory)}
For the game theory approach, the discussion provided in Section 2
provides most of the methodology for applying game theory to multitenant
scenarios for this research. The model is simplified by limiting
multitenant scenarios to two co-located tenants on a VM.
\newline\newline
The players for the game theory model are the different tenants
co-located on a specific VM. Players are rational and are trying to
maximise their utility. Utility represents, for this scenario,
increasing their resources to finish the execution of their
applications. The players can take the following actions, which are
scheduled by the controller:
\begin{itemize}
\item
  Decrease the number of used CPU cores
\item
 Increase the number of used CPU cores
\item
  Do nothing
\end{itemize}
In terms of the game, each game is simultaneous as all of the moves
will technically be made at the same time. There is imperfect
information as the players do not know what other players are doing.
Furthermore, a player does not know the predicted resource utilisation
of another or themselves. Players are non-cooperating as there is no
fixed agreement between them.
\newline\newline
The game was limited to two players to simplify the model. However,
it could be extended by adding more matrices for payoffs. The payoffs are
determined arbitrarily based on the assumption that everyone is punished
if the entire VM overuses its resource allocation. This is aligned with
the fact that if a pod, seen as a VM, requests too many resources, it
may be evicted. There is also an assumption that payoffs are determined
by the likelihood of breaking resource allocation thresholds.
\newline\newline
There is the assumption that the players are not related, i.e. they
are not dependent on each other. An example of related players is those
part of microservice applications. These applications require different
components to communicate with each other, such as passing data between
the components. The rationale behind excluding scenarios where there are
related players is that it would be expected that the players would
naturally coordinate their actions and resource usage.
\newline\newline
Therefore, this research focuses on unrelated players in multitenant
scenarios. In terms of the development of the game theory model,
arbitrary payoffs are assigned to the different decisions/actions of the
players. These payoffs can be formalised and sourced directly from the
Service Level Agreements (SLAs) from a cloud provider. The following
paragraph shows the logic applied to calculate the payoffs. In the figure,
there is reference made to `increases` and `decreases`, this should be
interpreted as `increases resource usage` and `decreases resource
usage`.
\newline\newline
The  logic applied to calculate the payoffs for the game
theory model includes:

\begin{itemize}
\item
If Player 1 increases and Player 2 decreases
  \begin{itemize}
  \item
    The chance of breaking resource allocation threshold is
    unchanged.
  \item
    Player 1 receives more benefit as it can use the resources
    technically freed by Player 2, so payoff is 10.
  \item
  Player 2 receives no benefit and instead incurs a cost as it is
    letting Player 1 use resources without improving the chance of
    breaking resource allocation threshold. Payoff is -5.
  \end{itemize}
\item
 If Player 1 decreases and Player 2 decreases

  \begin{itemize}
  \item
   The chance of breaking resource allocation threshold decreases.
  \item
    Player 1 receives benefit, so payoff is 5.
  \item
   Player 2 receives benefit, so payoff is 5.
  \end{itemize}
\item
 If Player 1 increases and Player 2 does nothing
  \begin{itemize}
  \item
    The chance of breaking resource allocation threshold is
    heightened as Player 1 has increased its resource utilisation.
  \item
    Player 1 increases its resource usage unnecessarily and is
    directly responsible for the increase in the chance of breaking
    resource allocation threshold as well. Payoff is -5.
  \item
   Player 2 has done nothing but is also indirectly responsible for
    the increase in the chance of breaking resource allocation threshold
    as well. Payoff is -2.5.
    \end{itemize}
  \item
  If Player 1 decreases and Player 2 stays the same.
    \begin{itemize}
    \item
    The chance of breaking the resource allocation threshold
      decreases.
    \item
     Player 1 has sacrificed some of its resources, costing its
      ability to execute its applications. Payoff -2.5.
    \item
    Player 2 has done nothing without sacrificing any ability to
      execute applications. Payoff 2.5.
    \end{itemize}
  \item
  If Player 1 does nothing and Player 2 does nothing
    \begin{itemize}
    \item
      No change in the chance of breaking the resource allocation
      threshold.
    \item
     Player 1 does nothing and does not reduce the chance of
      breaking the resource allocation threshold. Payoff -2.5.
    \item
      Player 2 does nothing and does not reduce the chance of
      breaking the resource allocation threshold. Payoff -2.5.
    \end{itemize}
  \item
    If Player 1 increases and Player 2 increases.
    \begin{itemize}
    \item
     The chance of breaking the resource allocation threshold is
      significantly worsened.
    \item
      Player 1 has directly influenced and worsened the chance of
      breaking the resource allocation threshold. Payoff -5.
    \item
      Player 2 has directly influenced and worsened the chance of
      breaking the resource allocation threshold. Payoff -5.
    \end{itemize}
\end{itemize}
The above logic can also be expressed in a matrix.
\begin{table}[H]
\centering
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{|c|c|c|c|c|}
\hline
&     & \multicolumn{3}{l|}{Player 2} \\
\hline
      &  & Increase number of CPU cores & Decrease number of CPU cores & Do nothing \\ \hline
\multirow{3}{*}{Player 1} & Increase number of CPU cores & -5,-5                        & 10,-5                        & -5, -2.5   \\ \hline
                          & Decrease number of CPU cores & -5, 10                       & 5, 5                         & -2.5, 2.5  \\ \hline
    & Do nothing                   & -2.5, 5                      & 2.5, -2.5                    & -2.5, -2.5  \\ \hline
\end{tabular}
\end{adjustbox}
\end{table}
Currently, each player does not consider and is not aware of the
other player. A player can assume a worst-case scenario where the other
player will choose to increase their number of CPU cores as it will see
a maximum payoff of 10. Therefore, the best decision for the other
player, only considering themselves, will be to do nothing. If the
player considers the whole game, the best decision is to decrease their
number of CPU cores. In contrast, if a player assumes that the other
player will choose to do nothing, then the player should also do nothing
to achieve the best payoff. This assumption, again, only considers the
players' individual gains. It should be
noted that the most gain is received for the whole game is 10 if both
players decrease their number of CPU cores.
\newline\newline
From Chapter 2, Nash's equilibrium exists where both players are not
motivated to change their decisions. In theory, Nash's equilibrium for
the above payoff matrix is for both players to do nothing assuming they
do not know what the other player will do. This is because this provides
a player with the best payoff irrespective of what the other player
does. Nevertheless, a better decision for both players is to reduce
their resource usage; however, this is unlikely in real multitenant
scenarios. Nash's equilibrium of the players doing nothing provides a
rationale for why users of clouds do not reduce their resource usage.

\subsection{Practical approach (Kubernetes)}
In addition to the theoretical approach described above, \emph{A Cat On A
Bed} is implemented on Kubernetes. Using Kubernetes allows for the
simulation of multitenant clouds. Applying \emph{A Cat On A Bed} to a realistic
multitenant scenario is essential in evaluating its' effectiveness in
managing GC utilisation when there is more than one application. This practical approach
addresses research question 1.

\subsubsection{Approach}

The goal of this part is to evaluate \emph{A Cat On A Bed's} performance
in multitenant scenarios. In Kubernetes, multitenant scenarios with shared resources occur
within a Pod with multiple containers; therefore, the testing focuses on a single Pod with either
one or two containers. Evaluating the performance of the JVMs is
accomplished through measuring the CPU utilisation, memory utilisation,
GC utilisation and performance time. In addition, the performance of a
JVM is significantly reduced if the Pod is evicted.
\subsubsection{Testing}

A selection of the JVMs from previous development phases was tested
in this phase. The chosen JVMs are listed below:
\begin{itemize}
\item
  JDKF
\item
  JDK0.5-0.5-1 (PID controller)
\item
  JDK1-1-3 (LQR controller)
\item
 JDK2-2-2 (LQR controller)

\item
  JDK2-3-2 (LQR controller)

\end{itemize}
The selection of JVMs is based on the results from the previous
phases. Generally, these selected JVMs performed well. Multiple JVMs
from Cat's Meow (the \emph{Linear-Quadratic Regulator} Controller phase) are
chosen as it was difficult to differentiate the better performer across
the different benchmarks or policies. JDKF, the original JVM, is tested
again to provide a benchmark of how the JVM typically performs on
Kubernetes.
\newline\newline
Based on the results from \emph{Circling} and \emph{Cat's Meow}, the testing suite
changed from individual benchmarks to running the five benchmarks in one
test run. This change in testing aims to address two considerations:
firstly, \emph{Circling} is not well suited to short-run applications, and
secondly, multitenant clouds generally have applications that tend to
longer execution time \cite{shen2011cloudscale}. Both of these
considerations meant that it was appropriate to have longer run tests.
The tests are, again, run with the four different GC policies and
repeated 16 times.
\newline\newline
In addition, as Kubernetes is a different environment to the earlier
testing environment for \emph{CatNap, Circling, and Cat's Meow}, the
testing for this phase is structured differently. It is
important to establish a baseline for all of the JVMs on Kubernetes to
understand their typical behaviour. This is achieved through testing a
single container in a Pod for each JVM. The multitenant aspect is tested
by having two containers in a Pod for each JVM. The containers are the
same JVM. Details of the setup files used for Kubernetes are provided in
Appendix A in a Github link. Future work could combine different JVMs to
identify if there is a change in performance and GC utilisation
management.
\newline\newline
The \emph{minikube} environment is used for running the tests, and it is
configured with 16-CPU cores and 16384 MB of memory. No attempt is made
to set the number of CPUs that the different or single container uses.
The rationale behind using \emph{minikube} is that it is suitable for the small
scope of testing and is compatible with appropriate add-ons, i.e.
\emph{metrics-server}. The add-on mentioned, \emph{metrics-server}, is required to
collect memory and CPU utilisation statistics.
\subsubsection{Results}
The focus of this phase is on multitenant scenarios; therefore,
evaluation of the different JVMs focuses on different vital statistics.
These statistics include GC utilisation, performance time, memory
utilisation and CPU utilisation. The statistics are separated into the
single container in a Pod and two containers in a Pod. Generally, the
findings reiterate the findings from earlier development phases; LQR
controllers are better at managing GC utilisation, whereas PID
controllers reduce execution time. In addition, PID controllers have
lower CPU utilisation linking to better performance. PID
controllers also have higher memory utilisation that reflects their
lowered ability to manage GC utilisation.
\newline\newline
\textbf{Single container in Pod}
\newline\newline
In terms of GC utilisation for a single container, there is a clear
trend that the LQR controllers have lower GC utilisation for GC policies
other than GenCon. JDK0.5-0.5-1, a PID controller, has less frequent GCs
than JDKF, the original JVM, and the LQR JVMs. The lower GC utilisation
for the JVMs with LQR controllers is more apparent with OptThruPut and
OptAvgPause. In contrast, JDK0.5-0.5-1 has similar GC utilisation to the
other LQR JVMs for GenCon and Balanced. Nevertheless, JDKF generally has
higher GC utilisation. These results can be observed from the next page of
graphs.
For CPU utilisation and a single JVM, there is generally lower CPU
utilisation for JDK0.5-0.5-1 (PID controller) compared to the other JVMs. This lower CPU utilisation reflects the
lowered performance time as well. In terms of the three LQR controllers,
there is little difference between their CPU utilisation and JDKF's, the
original JVM, irrespective of GC policy. There are similar results for
memory utilisation. These results can be seen in the graphs provided on
the next page. Not all of the graphs have the same scale because some of
them, particularly JDK0.5-0.5-1, have lower utilisation. Graphing on the
same scale makes it difficult to observe any trends within the separate
JVMs.

Similar to the findings from the earlier phases, JDK0.5-0.5-1 takes
a shorter time to execute the test benchmarks. This shorter time is more
apparent with OptThruPut and OptAvgPause. In addition, JDK1-1-3,
JDK8-9-9, JDK2-2-2 and JDK2-3-2 have worse performance than JDKF
irrespective of GC policy. The graphs relating to performance time are
provided on the next page.
The results from two containers in a Pod are similar to the results
from one container in a Pod; however, there are some slight differences
relating to the prioritisation of different containers.
\newline\newline 
The results for GC utilisation show that, irrespective of which
container is prioritised, GC utilisation is similar to the GC
utilisation for a single container in a Pod. In addition, GC utilisation
for each container is usually around the same value. Again, the LQR
controllers perform better in terms of GC utilisation management. The better management of GC utilisation by the LQR controllers
is reflected in the graphs below and on the next page. GC utilisation is also
lower with OptThruPut and OptAvgPause policy compared to Balanced and
GenCon. These findings for GC utilisation reiterate the findings from
earlier phases.
CPU utilisation and memory utilisation tend to have similar
patterns. Overall, having two containers in a Pod does not affect the
CPU utilisation and memory utilisation compared to having one container
in a Pod; therefore, similar results for a single container in a pod
apply to two containers in a pod. However, this perspective of the
results occur when an overall view is taken, i.e. the two containers'
memory and CPU utilisation are taken together. Separately, it is clear
that one of the containers will usually have lower CPU utilisation and
memory utilisation even compared to the results earlier for a single
container in a pod. Another difference is that JDK0.5-0.5-1 does not
perform as well with two containers in a pod. For example, with two
containers, the memory utilisation spikes to 4000MiB for OptThruPut
policy compared to JDKF's, the original JVM, highest spike of
400\% for OptThruPut policy. This spike for JDK0.5-0.5-1 is unexpected,
considering the better performance of the JVM for one container in a
pod. An excerpt of the graphs is provided below.
Graphing the performance times of the different JVMs reiterates the
findings from a single container in a Pod; JDK0.5-0.5-1 has better
performance and the LQR JVMs have the worst performance. In addition, it
appears that there is an inverse relationship between the performance
time of the two containers in a Pod, i.e. one container has lower
performance time, and the other container then has a higher performance
time. Having this type of relationship indicates the impact of
multitenant scenarios. Furthermore, there is a lower difference between
the two containers' performance for the modified JVM's shown by a
smaller distance between the two containers for the modified JVMs on the
graphs. These graphs are provided on the next page.
\subsection{Summary}

Multitenant scenarios are a crucial facet of this research and are
addressed through a theoretical approach, game theory, and a practical
approach focusing on Kubernetes. The theoretical approach, game theory,
shows that Nash's equilibrium exists where both players do nothing;
however, a better alternative is for the players to decrease their
resource usage. In terms of the practical approach, the results
reiterate the findings from the earlier phases relating to performance
time and GC utilisation. These findings show that an LQR controller in
the JVM is better for controlling GC utilisation but does not have a
positive impact on performance time. In contrast, a PID controller in the
JVM is better in reducing performance time but is not effective in
managing GC utilisation.


